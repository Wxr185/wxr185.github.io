<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> WXR</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover3.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">WXR</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['人生若只如初见，何事秋风悲画扇', '等闲变却故人心，却道故人心易变', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-NLP/Word2Vec"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/25/NLP/Word2Vec/"
    >Word2Vec</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/25/NLP/Word2Vec/" class="article-date">
  <time datetime="2022-09-25T07:53:50.532Z" itemprop="datePublished">2022-09-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/">自然语言处理</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="什么是Word2Vec"><a href="#什么是Word2Vec" class="headerlink" title="什么是Word2Vec?"></a>什么是Word2Vec?</h3><p>Word2Vec模型实际上分了两个部分，第一部分建立模型，第二部分通过模型获取嵌入词向量。<br>Word2Vec的整个建模过程实际上与自编码器的思想很相似。</p>
<blockquote>
<p>先基于训练数据构建神经网络。当模型训练好以后，我们并不会使用这个训练好的模型处理新的任务，我们需要的是通过训练数据学习得到的参数，例如隐层的权重矩阵。</p>
</blockquote>
<p>Word2Vec的训练模型本质上是只具有一个隐含层的神经元网络，从大量文本语料中以无监督的方式学习语义知识。<br><img src="/pictures/NLP/Word2Vec/img1.jpg.png" alt="Word2Vec单层网络结构"></p>
<blockquote>
<ul>
<li>输入是One-Hot向量，Hidden Layer的激活函数是线性。Output Layer维度和Input Layer维度相同，用的是Softmax回归；</li>
<li>训练Word2Vec需要用到反向传播算法，本质是链式求导；</li>
<li>我们并不关心模型训练任务，我们真正需要的是这个模型通过学习得到的参数，即隐层的权重矩阵；</li>
<li>Word2Vec本质是一种降维操作。</li>
</ul>
</blockquote>
<p>Word2Vec其实就是通过学习文本来用词向量的方式表征词的语义信息，即通过一个嵌入空间是的语义相似的单词在该空间内距离很近。<br><strong>Embedding</strong> 其实就是一个映射，将单词从原先所属的空间映射到新的多维空间中。通过对词汇表中单词进行这种数值表示方式的学习，能够进行 <em><strong>向量化</strong></em> 的操作。  </p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>Word2Vec模型中，主要有两种结构：</p>
<blockquote>
<ul>
<li><strong>CBOW模型</strong> ：训练输入是某一个特征词的上下文相关的词对应的词向量，而输出就是这特定的一个词的词向量；  </li>
<li><strong>Skip-gram模型</strong> ：输入是特定的一个词的词向量，而输出是特定词对应的上下文词向量；</li>
</ul>
</blockquote>
<p><img src="/pictures/NLP/Word2Vec/img2.png" alt="Word2Vec网络结构"></p>
<h4 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h4><p>Skip-gram模型，通过中间词预测上下文。</p>
<ul>
<li>首先，选择句子中的一个词作为中心词；</li>
<li>定义skip_window参数，限制从中心词左右可以选词的范围；</li>
<li>神经网络基于这些训练数据将会输出一个概率分布，这个概率代表词典中每个词是上下文的可能性。</li>
</ul>
<p>训练样本的构成是通过选择输入词前后skip_window范围内的词语与输入词进行组合。下图中，蓝色代表input word，方框内代表位于窗口内的单词。<br><img src="/pictures/NLP/Word2Vec/img5.png" alt="训练样本构建"><br>模型将会从每对单词出现的次数中学习得到统计规律。</p>
<p>以下是Skip-gram模型结构：<br><img src="/pictures/NLP/Word2Vec/img3.png" alt="Skip-gram网络结构"><br>隐层没有使用任何激活函数，但是输出层使用了softmax。<br>我们基于成对的单词来对神经网络进行训练，训练样本是上述单词对，其中input word和output word都是onehot向量。最终模型输出是一个概率分布。</p>
<blockquote>
<p>可以看成y &#x3D; f(x)模型的并联，cost function是单个cost function的累加 <strong>（取log之后）</strong>。</p>
</blockquote>
<h4 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h4><p><img src="/pictures/NLP/Word2Vec/img4.jpg" alt="CBOW网络结构"><br>注意到，跟Skip-gram模型的并联不同，CBOW输入要对多个单词进行输入处理，一般是求和然后平均，输出的cost function不变。</p>
<blockquote>
<ol>
<li>输入层：上下文单词的one-hot向量表示；</li>
<li>所有one-hot向量分别乘以共享的输入权重矩阵W；</li>
<li>所得的向量 <strong>相加求平均</strong> 作为隐层向量；</li>
<li>乘以输出矩阵W’；</li>
<li>得到向量，经过softmax函数处理得到V-dim概率分布；</li>
<li>概率最大的index所指示的单词作为预测词与true label的one-hot做比较，误差越小越好（根据误差更新权重矩阵）。</li>
</ol>
</blockquote>
<h3 id="训练Tricks"><a href="#训练Tricks" class="headerlink" title="训练Tricks"></a>训练Tricks</h3><p>Word2Vec本质上是一个语言模型，它的输出节点数是V个，对应了V个词语，本质上是一个多分类问题。但实际当中，词表数量巨大，计算复杂度巨高，所以需要技巧来加速训练。</p>
<blockquote>
<ul>
<li>层级softmax：本质是把N分类问题变成log(N)次的二分类；</li>
<li>负采样：本质是预测总体类别的一个子集</li>
</ul>
</blockquote>
<h4 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h4><p>在训练神经网络时，每个训练样本都将会调整所有神经网络中参数。词汇表决定了Word2Vec模型将会有非常大的权重矩阵，并且所有权重参数会随着数十亿训练昂呢不断调整。<br>负采样每次让一个训练样本更新一小部分的权重参数，从而降低梯度下降过程中的计算成本。  </p>
<p>负样本的选择规则：一个单词被选作负采样的概率与它出现的频次有关，出现频次越高的单词越容易被选择作为负样本，经验公式如下：<br><img src="/pictures/NLP/Word2Vec/img6.png.webp" alt="负采样概率"><br>f(w)代表每个单词被赋予的一个权重，即出现的词频。</p>
<h4 id="层序Softmax"><a href="#层序Softmax" class="headerlink" title="层序Softmax"></a>层序Softmax</h4><p>Huffman原理：权重越大的节点，越靠近根节点。</p>
<blockquote>
<ol>
<li>对每个词按照权重进行排序，将每次词看成一个独立的单节点的树；</li>
<li>合并最小的两个子树，新的根节点权重为两者根节点权重之和；</li>
<li>将新的树插入排序进树集合中；</li>
<li>重复2，3步骤，直到合并所有树。</li>
</ol>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><blockquote>
<p>cbow是用周围词预测中心词，训练过程中其实是在从output的loss学习周围词的信息也就是embedding，但是在中间层是average的，一共预测V次；<br>skip-gram是用中心词预测周围词，对每一个中心词都有K个词作为output，对一个词的预测有K次，所以能够更有效的从context中学习信息，共预测K*V次，因此，skip-gram的训练时间更长。</p>
</blockquote>
<p>鉴于skip-gram学习的词向量更细致，当 <strong>数据量较少或者语料库中有大量低频词</strong> 时，使用skip-gram学习比较合适。</p>
<blockquote>
<p>CBOW中的目标函数是使条件概率P(w|context(w))最大化<br>Skip-gram中的目标函数是使条件概率P(context(w)|w)最大化</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NLP/" rel="tag">NLP</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Normalization"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/25/Normalization/"
    >Normalization</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/25/Normalization/" class="article-date">
  <time datetime="2022-09-25T07:48:34.905Z" itemprop="datePublished">2022-09-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>机器学习领域有个很重要的假设：IID (Independent Identically Distribution) 独立同分布假设，即假设训练数据和测试数据是满足同分布的。</p>
<blockquote>
<p>神经网络的学习过程本质上是为了学习数据的分布。<br>在mini-batch梯度下降训练的时候，如果每批训练数据的分布不同，那么网络在每次迭代的时候都要学习适应不同的分布，大大降低了网络的训练速度。</p>
</blockquote>
<h2 id="BatchNorm"><a href="#BatchNorm" class="headerlink" title="BatchNorm"></a>BatchNorm</h2><p>BatchNorm就是在深度神经网络训练过程中，使得每一层神经网络的输入保持相同分布。</p>
<p>BN层在激活函数之前。BN层的作用机制：通过平滑隐藏层输入的分布，帮助随机梯度下降的进行，缓解随机梯度下降随遇后续层的负面影响。</p>
<blockquote>
<ol>
<li>sigmoid, tanh激活函数。函数图像两端，梯度较小，容易出现 <strong>梯度衰减</strong> 问题。因此，把BN层放在非线性激活函数之前，将数据分布调整到均值为0附近，加速训练。</li>
<li>relu激活函数。relu函数负半区的输出值被抑制，正半区的值被保留。因此，BN层放在前面，可以防止某一层的激活值全部被抑制，导致梯度全部为0，梯度消失。同理，防止梯度爆炸。</li>
</ol>
</blockquote>
<h3 id="Internal-Covariate-Shift-问题"><a href="#Internal-Covariate-Shift-问题" class="headerlink" title="Internal Covariate Shift 问题"></a>Internal Covariate Shift 问题</h3><p>在训练过程中，隐层的 <em><strong>输入分布</strong></em> 总是变来变去。导致下一层网络很难进行学习（神经网络本来就是要学习数据分布的）。</p>
<blockquote>
<p>Internal Covariate Shift: 发生在神经网络内部；<br>Covariate Shift: 发生在输入数据上。主要描述由于训练数据和测试数据存在分布差异，影响模型的泛化性和训练速度。</p>
</blockquote>
<h3 id="BatchNorm基本思想"><a href="#BatchNorm基本思想" class="headerlink" title="BatchNorm基本思想"></a>BatchNorm基本思想</h3><p>深度神经网络在做 <strong>非线性变化前</strong> 的激活输入值随着网络深度加深，在训练过程中，数据分布逐渐向着 <strong>非线性函数取值区间的上下限两端靠近</strong>，导致反向传播时，低层神经网络梯度消失，最终造成收敛变慢。</p>
<p>BN就是规范化隐层数据分布，将数据分布强制规范到非线形激活函数比较敏感的区域，避免梯度消失问题产生。<br>就是说经过BN后，大部分输出值落在非线形函数的非饱和区，加速收敛过程。</p>
<blockquote>
<p>如果都通过BN，那么不就跟把非线性函数替换成线性函数效果相同了？这意味着什么？我们知道，如果是多层的线性函数变换其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的表达能力下降了，这也意味着深度的意义就没有了。</p>
</blockquote>
<p>BN为了保证模型的非线形，对变换后的数据分布，进行了scale加上shift操作，<strong>这两个参数通过训练学习得到</strong>。等价于非线性函数的值，从正中心周围的线性区域往非线性区域偏移。增强模型的表达能力。</p>
<blockquote>
<p><strong>BN的核心思想：</strong>在非线性和线性之间找到较好的平衡点。既能享受非线性较强的表达能力，又能避免非线性激活函数饱和区梯度消失问题。</p>
</blockquote>
<h3 id="BatchNorm训练阶段"><a href="#BatchNorm训练阶段" class="headerlink" title="BatchNorm训练阶段"></a>BatchNorm训练阶段</h3><p>对于mini-batch SGD来说，一次训练过程中包含m个训练实例，其具体BN操作就是对于隐层中 <strong>每个神经元</strong> 的激活值，进行如下变换：<br><img src="/pictures/AI/Normal/img1.png" alt="每个神经元数据的标准化操作"></p>
<p>经过上述变化后，某个神经元的激活值变成了N(0, 1)正态分布。<br>为了防止网络表达能力下降，每个神经元增加两个调节参数，这两个参数通过训练学习得到，用来还原网络非线性表达能力。<br><img src="/pictures/AI/Normal/img2.png" alt="数据的放缩与偏移"></p>
<p>BN的具体操作流程如下，</p>
<blockquote>
<ol>
<li>先求出此次批量数据x的均值</li>
<li>求出此次batch的方差</li>
<li>接下来就是对x做归一化</li>
<li>最重要的一步，引入缩放和平移变量γ和β ,计算归一化后的值</li>
</ol>
</blockquote>
<p><img src="/pictures/AI/Normal/img3.png" alt="BN具体流程"></p>
<p>一个简单的代码实现，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def BatchNorm(x, gamma, beta, bn_param):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">param:x		: 输入数据，shape(B, L)</span><br><span class="line">param:gamma	: 缩放因子</span><br><span class="line">param:beta	: 平移因子</span><br><span class="line">param:bn_param	: batchnorm所需要的一些参数</span><br><span class="line">	eps		: 接近0的数，防止分母出现0</span><br><span class="line">	momentum	: 动量参数，一般为0.9，0.99，0.999</span><br><span class="line">	running_mean	: 滑动平均的方式计算新的均值</span><br><span class="line">	running_var	: 滑动平均的方式计算新的方差</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    x_mean = x.mean(axis=0)</span><br><span class="line">    x_var = x.var(axis=0)</span><br><span class="line">    x_norm = (x - x_mean) / np.sqrt(x_var + eps)</span><br><span class="line">    x_norm = gamma * x_norm + beta</span><br><span class="line"></span><br><span class="line">    # 滑动平均计算得到均值方差信息，用于推断阶段</span><br><span class="line">    running_mean = bn_param[&#x27;running_mean&#x27;]</span><br><span class="line">    running_var = bn_parma[&#x27;running_var&#x27;]</span><br><span class="line">    momentum = bn_param[&#x27;momentum&#x27;]</span><br><span class="line"></span><br><span class="line">    running_mean = momentum * running_mean + (1-momentum) * x_mean</span><br><span class="line">    running_var = momentum * running_var + (1-momentum) * x_var</span><br><span class="line"></span><br><span class="line">    bn_param[&#x27;running_mean&#x27;] = running_mean</span><br><span class="line">    bn_param[&#x27;running_var&#x27;] = running_var</span><br><span class="line"></span><br><span class="line">    return x_norm, bn_param</span><br></pre></td></tr></table></figure>

<p>在训练中完成的任务，每次训练给一个批量，然后计算批量的均值方差，但是在测试的时候可不是这样，测试的时候 <strong>每次只输入一张图片</strong>，这怎么计算批量的均值和方差，于是，就有了代码中下面两行，在训练的时候实现计算好mean和var，测试的时候直接拿来用就可以了，不用计算均值和方差。</p>
<h3 id="BatchNorm优势"><a href="#BatchNorm优势" class="headerlink" title="BatchNorm优势"></a>BatchNorm优势</h3><blockquote>
<ol>
<li>不仅仅极大提升了训练速度，收敛过程大大加快；</li>
<li>还能增加分类效果，一种解释是这是类似于Dropout的一种防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果；</li>
<li>另外调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等；</li>
<li>batchnorm降低了数据之间的绝对差异，有一个去相关的性质，更多的考虑相对差异性，因此在分类任务上具有更好的效果。</li>
</ol>
</blockquote>
<h2 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h2><h3 id="BatchNorm缺点"><a href="#BatchNorm缺点" class="headerlink" title="BatchNorm缺点"></a>BatchNorm缺点</h3><p>Batch size太小会影响模型性能。对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以 <strong>如果batchsize太小，则计算的均值、方差不足以代表整个数据分布</strong>；</p>
<p>BN实际使用时需要计算并且保存某一层神经网络batch的均值和方差等统计信息，对于对一个固定深度的前向神经网络（DNN，CNN）使用BN，很方便；但对于RNN来说，sequence的长度是不一致的，换句话说RNN的深度不是固定的，不同的time-step需要保存不同的statics特征，可能存在一个特殊sequence比其他sequence长很多，这样training时，计算很麻烦。</p>
<p>BN不适用于RNN等动态网络，适用于CNN；LN适用于RNN。</p>
<blockquote>
<p>很直观的一个例子：BN计算每个句子同一个位置字的均值和方差，但因为每个句子的长度不一样，最后是padding成一样的长度；那假如在该位置时，最后一句在该位置是没有字的，也就是用0表示了，那就会影响整个结果。</p>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>BN的主要思想：在每一层的每一批数据（一个batch里的同一个通道）上进行归一化；<br>LN的主要思想：在每一个样本（一个样本的不同通道）上计算均值和方差，并不是BN那种在批方向计算均值和方差。<br><img src="/pictures/AI/Normal/img4.png" alt="BN和LN的区别"></p>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>Layer Normalization在NLP的直观图中，就是对一个batch中的同一句话中的 <strong>每个字</strong> 分别进行归一化。</p>
<p>如果只看 NLP 问题，假设我们的 batch 是（2,3,4）的，也就是 batch_size &#x3D; 2, seq_length &#x3D; 3, dim &#x3D; 4 的，假设第一个句子是 w1 w2 w3，第二个句子是 w4 w5 w6，那么这个 tensor 可以写为</p>
<blockquote>
<p>[ [[w11,w12,w13,w14], …]<br>[[w41,w42,w43,w44], …] ]</p>
</blockquote>
<p>如果是 BN 的话，会对同一个 batch 里对应位置上的 token 求平均值，也就是说 (w11+w12+w13+w14+w41+w42+w43+w44)&#x2F;8是其中一个 mean，一共会求出 3 个 mean，也就是上图里 C 个（seq_length）个 mean。</p>
<p>如果是 LN 的话，<strong>看起来（其实并不是）</strong> 是对每个 sample 里的所有 feature 求 mean，也就是(w11+w12+w13+w14+w21+w22+w23+w24+w31+w32+w33+w34)&#x2F;12，可以求出一共 2 个 mean，也就是图里 N（batch_size）个 mean。<br><img src="/pictures/AI/Normal/img5.png" alt="Layer Norm的不同"></p>
<p>左图和我们认为的 LN 一致，也是我一直认为的 LN，但是右图却是在一个 token 上求平均，带回我们原来的问题，对于一个(2,3,4)的 tensor，(w11+w12+w13+w14)&#x2F;4 是一个 mean，一共会有 2*3&#x3D;6 个 mean。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/9-内联函数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/18/Programming/C++/9-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"
    >第9章 内联函数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/18/Programming/C++/9-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2022-09-18T14:03:01.151Z" itemprop="datePublished">2022-09-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在C中，保持效率的一个方法是使用宏(macro)。宏可以不要普通的函数调用代价 就可使之看起来像函数调用。宏的实现是用预处理器而不是编译器。预处理器直接用宏代 码代替宏调用，所以就没有了参数压栈、生成汇编语言的CALL、返回参数、执行汇编语 言的RETURN等的开销。所有的工作由预处理器来完成，因此不用花费什么就具有了程序 调用的便利和可读性。</p>
<p>在C++中，使用预处理器宏存在两个问题。</p>
<blockquote>
<ul>
<li>第一个问题在C中也存在:宏看起来像一个函数调用，但并不总是这样。这样就隐藏了难以发现的错误。</li>
<li>第二个问题是C++特有的:预处理器不允许访问类的成员数据。这意味着预处理器宏不能用作类的成员函数。</li>
</ul>
</blockquote>
<h3 id="预处理器的缺陷"><a href="#预处理器的缺陷" class="headerlink" title="预处理器的缺陷"></a>预处理器的缺陷</h3><p>第一个问题是表达式在宏内展开，所以它们的优先级不同于所期望的优先级。<br>第二个问题则复杂一些。不像普通函数，每次在宏中使用一个参数，都对这个参数求值。只要使用普通变量调用宏仅，求值就无危险。但假如参数求值有副作用，那么结果可能出乎预料，并肯定不能模仿函数行为。</p>
<h4 id="宏和访问"><a href="#宏和访问" class="headerlink" title="宏和访问"></a>宏和访问</h4><p>预处理器只是简单地执行字符替代。</p>
<p>在宏里简直没有办法表示类的范围。由于没 有可以取代预处理器宏的方法，程序设计者出于效率考虑，不得不让一些数据成员成为 public类型，这样就会暴露内部实现并妨碍在这个实现中的改变，从而消除了private提供的保护。</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>联函数能够像普通函数一样具有我们所有期望的任何行为。惟一不同之处是内联函数在适当的地方像宏一样展开，所以不需要函数调用的开销。</p>
<p>任何在类中定义的函数自动地成为内联函数，但也可以在非类的函数前面加上inline 关键字使之成为内联函数。但为了使之有效，必须使函数体和声明结合在一起，否则，编 译器将它作为普通函数对待。</p>
<p>一般应该把内联定义放在头文件里。当编译器看到这个定义时，它把函数类型(函数 名+返回值)和函数体放到符号表里。当使用函数时，编译器检查以确保调用是正确的且 返回值被正确使用，然后将函数调用替换为函数体，因而消除了开销。内联代码的确占用 空间，但假如函数较小，这实际上比为了一个普通函数调用而产生的代码(参数压栈和执 行CALL)占用的空间还少。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/" rel="tag">Programming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/8-常量"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/18/Programming/C++/8-%E5%B8%B8%E9%87%8F/"
    >第8章 常量</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/18/Programming/C++/8-%E5%B8%B8%E9%87%8F/" class="article-date">
  <time datetime="2022-09-18T13:38:50.474Z" itemprop="datePublished">2022-09-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>常量概念(由关键字const表示)是为了使程序员能够在变和不变之间画一条界线。这在C++程序设计项目中提供了安全性和可控性。</p>
<p>const的最初动机是取代预处理器#defines来进行值替代。从这以后它曾被用于指针、 函数变量、返回类型、类对象以及成员函数。</p>
<h3 id="值替代"><a href="#值替代" class="headerlink" title="值替代"></a>值替代</h3><p>当用C语言进行程序设计时，预处理器可以不受限制地建立宏并用它来替代值。因为预处理器只做些文本替代，它既 <strong>没有类型检查概念</strong>，也没有 <strong>类型检查功能</strong>，所以预处理器的值替代会产生一些微小的问题，这些问题在C++中可以通过使用const值而避免。</p>
<p>C++用const来消除 <strong>宏定义没有类型信息</strong> 问题，具体方法是把值替代移交给编译器。</p>
<h4 id="头文件里的const"><a href="#头文件里的const" class="headerlink" title="头文件里的const"></a>头文件里的const</h4><p>要使用const而非#define，同样必须把const定义放进 <strong>头文件</strong> 里。这样，通过包含头文件，可把const定义单独放在一个地方并把它分配给一个编译单元。C++中的const默认为 内部连接(internal linkage)，也就是说，const仅在const被定义过的文件里才是可见的， 而在连接时不能被其他编译单元看到。</p>
<p>当定义一个const时，<strong>必须赋一个值给它，除非用extern作出了清楚的说明</strong>。</p>
<p>通常C++编译器并 <strong>不为const创建存储空间</strong>，相反它把这个定义保存在它的符号表里。<br>上面的extern强制进行了存储空间分配(另外还有一些情况，如取一个const的地址，也要进行存储空间分配)，由于extern意味着使用 <strong>外部连接</strong> ，因此 <strong>分配存储空间</strong>，这也就是说有几个不同的编译单元应当能够引用它，所以它必须有存储空间。</p>
<p>由于编译器不能完全避免为const分配内存，所以const的定义必须 <strong>默认内部连接</strong>，即连接仅在特定的编译单元内;否则，由于众多的const在多个cpp文件内分配存储，容易引起连接错误，连接程序在多个对象文件里看到同样的定义就会“抱怨”。然而，因为const默认内部连接，所以连接程序不会跨过编译单元连接那些定义，因此不会有冲突。在大部分场合使用内建数据类型的情况，包括常量表达式，编译都能执行常量折叠。</p>
<h4 id="const的安全性"><a href="#const的安全性" class="headerlink" title="const的安全性"></a>const的安全性</h4><p>const的作用不仅限于在常数表达式里代替#defines。如果用运行期间产生的值初始化一个变量而且知道在变量生命期内是不变的，则用const限定该变量是程序设计中的一个很好的做法。</p>
<p>就实际来说，如果想让一个值不变，就应该使之成为const。这不仅为防止意外的更改提供安全措施，也消除了读存储器和读内存操作，使编译器产生的代码更有效。</p>
<h4 id="与C语言的区别"><a href="#与C语言的区别" class="headerlink" title="与C语言的区别"></a>与C语言的区别</h4><p>C中const的意思是“一个不能被改变的普通变量”，const常量总是占用存储而且它的名字是全局符。</p>
<p>C默认const是外部连接的；C++默认const是内部连接。<br>在C++中，一个const不必创建内存空间，而在C中，一个const总是需要创建一块内存空间。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>当使用带有指针的const时，有两种选择:const修饰指针正指向的对象，或者const修饰在指针里存储的地址。</p>
<h4 id="指向const的指针"><a href="#指向const的指针" class="headerlink" title="指向const的指针"></a>指向const的指针</h4><p>正如任何复杂的定义一样，定义指针的技巧是在标识符的开始处读它并从里向外读。const修饰“最靠近”它的那个。</p>
<h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>使指针本身成为一个const指针，必须把const标明的部分放在*的右边。</p>
<p>因为指针本身现在是const指针，编译器要求给它一个初始值，这个值在指针生命期间内不变。然而要改变它所指向的值是可以的。</p>
<h4 id="赋值和类型检查"><a href="#赋值和类型检查" class="headerlink" title="赋值和类型检查"></a>赋值和类型检查</h4><p>可以把一个非const对象的地址赋给一个const指针，因为也许有时不想改变某些可以改变的东西。<br>然而，不能把一个const对象的地址赋给一个非const指针，因为这样做可能通过被赋值的指针改变这个对象的值。</p>
<h3 id="函数参数和返回值"><a href="#函数参数和返回值" class="headerlink" title="函数参数和返回值"></a>函数参数和返回值</h3><p>如果按值传递对象，对客户来讲，用const限定没有意义(它意味着传递的参数在函数里是不能被修改的)。<br>如果按常量返回用户定义类型的一个对象的值，这意味着返回值不能被修改。<br>如果传递并返回地址，const将保证该地址内容不会被改变。</p>
<h4 id="传递const值"><a href="#传递const值" class="headerlink" title="传递const值"></a>传递const值</h4><p>在函数里，const有这样的意义:参数不能被改变。所以它其实是函数创建者的工具，而不是函数调用者的工具。</p>
<p>为了不使调用者混淆，在函数内部用const限定参数优于在参数表里用const限定参数。</p>
<h4 id="返回const值"><a href="#返回const值" class="headerlink" title="返回const值"></a>返回const值</h4><p>对返回值来讲，存在一个类似的道理，即如果一个函数的返回值是一个常量（const）。这就约定了函数框架里的原变量不会被修改。另外。因为这是按值返回的，所以这个变量被制成副本，使得初值不会被返回值所修改。</p>
<p>当处理用户定义的类型时，按值返回常量是很重要的。如果一个函数按值返回一个类对象为const时，那么这个函数的返回值不能是一个左值(即它不能被赋值，也不能被修改)。</p>
<h4 id="传递和返回地址"><a href="#传递和返回地址" class="headerlink" title="传递和返回地址"></a>传递和返回地址</h4><p>如果传递或返回一个地址(一个指针或一个引用)，客户程序员去取地址并修改其初值是可能的。<br>如果使这个指针或者引用成为const，就会阻止这类事的发生，这是非常重要的事情。<br>事实上，无论什么时候传递一个地址给一个函数，都应该尽可能用const修饰它。如果不这样做，就不能以const指针参数的方式使用这个函数。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>为了保证一个类对象为常量，引进了const成员函数:const成员函数只能对于const对象调用。</p>
<h4 id="类里的const"><a href="#类里的const" class="headerlink" title="类里的const"></a>类里的const</h4><p>常数表达式使用常量的地方之一是在类里。典型的例子是在一个类里建立一个数组，并用const代替#define设置数组大小以及用于有关数组的计算。数组大小一直隐藏在类里，这样，如果用size表示数组大小，就可以把size这个名字用在另一个类里而不发生冲突。然而所有的#define从定义的地方起就被预处理器看成是全局的，所以用#define就不会得到预期的效果。</p>
<p>它在每个类对象里分配存储并代表一个值，这个值一旦被初始化以后就不能改变。在一个类里使用const意味着“在这个对象生命期内，它是一个常量”。然而，对这个常量来讲，每个不同的对象可以含有一个不同的值。</p>
<p><strong>在一个类里建立一个普通的（非static的）const时，不能给它初值。这个初始化工作必须在构造函数里进行。</strong></p>
<h4 id="编译期间类里的常量"><a href="#编译期间类里的常量" class="headerlink" title="编译期间类里的常量"></a>编译期间类里的常量</h4><p>如何让一个类有编译期间的常量成员?这就要求使用另外一个关键字static。</p>
<p>关键字static意味着“不管类的对象被创建多 少次，都只有一个实例”，这正是所需要的:类中的一个常量成员，在该类的所有对象中 它都一样。因此，一个内建类型的static const可以看做一个编译期间的常量。</p>
<h4 id="const对象和成员函数"><a href="#const对象和成员函数" class="headerlink" title="const对象和成员函数"></a>const对象和成员函数</h4><p>编译器强调对象为const的，因此它必须保证对象的数据成员在其生命期内不被改变。</p>
<p>仅仅声明一个函数在类定义里是const的，还不能保证成员函 数按声明的方式去做，所以编译器强迫程序员在定义函数时要重申const说明。</p>
<p>为确保函数定义的 常量性，如果我们改变对象中的任何成员或调用一个非const成员函数，编译器就将发出 一个出错信息。</p>
<p>要理解声明const成员函数的语法，首先注意前面的带const的函数声明，它表示函数 的返回值是const，但这不会产生想要的结果。相反，必须把修饰符const放在函数参数表 的后面。</p>
<p>关键字const必须用同样的方式重复出现在定义里，否则编译器把它看成一个不同的 函数。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile的语法与const是一样的，但是volatile的意思是“在编译器认识的范围外，这个 数据可以被改变”。可以被其他进程修改，不能被自己修改。</p>
<p>如果编译器说:“我已经把数据读进寄存器，而且再没有与寄存器接触”。一般情况 下，它不需要再读这个数据。但是，如果数据是volatile修饰的，编译器就不能作出这样的 假定，因为这个数据可能被其他进程改变了，它必须重读这个数据而不是优化这个代码来 消除通常情况下那些冗余的读操作代码。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关键字const能将对象、函数参数、返回值和成员函数定义为常量，并能消除预处理 器的值替代而不使预处理器的影响。所有这些都为程序设计提供了又一种非常好的类型检 查形式以及安全性。使用所谓的常量正确性(const correctness)(在任何可能的地方使用 const)已成为项目的救星。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/" rel="tag">Programming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/7-函数重载与默认参数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/17/Programming/C++/7-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"
    >第7章 函数重载与默认参数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/17/Programming/C++/7-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/" class="article-date">
  <time datetime="2022-09-17T10:29:00.417Z" itemprop="datePublished">2022-09-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>函数重载意味着，我们有两个库，它们都有同名的函数，只要它们的参数列表不同就不会发生冲突。</p>
<h3 id="名字修饰"><a href="#名字修饰" class="headerlink" title="名字修饰"></a>名字修饰</h3><p>我们建议在函数名前加 类名的方法来命名函数，所以编译器使用的内部名字可能就是_f和_X_f。函数名不仅与类 名关系密切，而且还跟其他因素有关。</p>
<p>可以对不同的函数用同样的名字，只要求函数的参数不同。编译器会修饰这些名字、范围和参数来产生内部名以供它和连接器使用。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>默认参数是在函数声明 时就已给定的一个值，如果在调用函数时没有指定这一参数的值，编译器就会自动地插上这个值。</p>
<p>在使用默认参数时必须记住两条规则。</p>
<ol>
<li>只有参数列表的后部参数才是可默认的，也就是说，不可以在一个默认参数后面又跟一个非默认的参数。</li>
<li>一旦在一个函数调用中开始使用默认参数，那么这个参数后面的所有参数都必须是默认的(这可以从第一条中导出)。</li>
</ol>
<p>默认参数只能放在 <strong>函数声明</strong> 中，通常在一个头文件中。编译器必须在使用该函数之前知道默认值。</p>
<h4 id="占位符参数"><a href="#占位符参数" class="headerlink" title="占位符参数"></a>占位符参数</h4><p>函数声明时，参数可以没有标识符，当这些不带标识符的参数用做默认参数时，看起<br>来很有意思。</p>
<p>这种语 法允许把一个参数用做占位符而不去用它。其目的在于以后可以修改函数定义而不需要修 改所有的函数调用。</p>
<h3 id="选择重载还是默认参数"><a href="#选择重载还是默认参数" class="headerlink" title="选择重载还是默认参数"></a>选择重载还是默认参数</h3><p>不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。一个默认的参数应该是一个在一般情况下放在这个位置的值。这个值出现的可能比其他值要大，所以客户程序员可以忽略它或只在需要改变默认值时才去用它。</p>
<p>默认参数的引用是为了使函数调用更容易，特别是当这些函数的许多参数都有特定值时。它不仅使书写函数调用更容易，而且阅读也更方便，尤其是当类的创建者能够制定参数，以便把那些最不可能调整的默认参数放在参数表的最后面时。</p>
<p>默认参数的一个重要应用情况是在开始定义函数时用了一组参数，而使用了一段时间后发现要增加一些参数。通过把这些新增参数都作为默认的参数，就可以保证所有使用这一函数的客户代码不会受到影响。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programmming/" rel="tag">Programmming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/6-初始化与清除"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/17/Programming/C++/6-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4/"
    >第6章 初始化与清除</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/17/Programming/C++/6-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4/" class="article-date">
  <time datetime="2022-09-17T09:59:08.220Z" itemprop="datePublished">2022-09-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="用构造函数确保初始化"><a href="#用构造函数确保初始化" class="headerlink" title="用构造函数确保初始化"></a>用构造函数确保初始化</h3><p>类的设计者可以通过提供一个叫做 <strong>构造函数(constructor)</strong> 的特殊函数来 <strong>保证每个对象都被初始化</strong>。如果一个类有构造函数，<strong>编译器在创建对象时就自动调用这一函数</strong>，这一切在客户程序员使用他们的对象之前就已经完成了。是否调用构造函数不需要客户程序员来考虑，它是由编 译器在对象定义时完成的。</p>
<p><strong>构造函数的名字与类的名字一样</strong>。这样的函数在初始化时会自动被调用。</p>
<p>传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一函数的对象的地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是 <strong>正确的初始化该内存块</strong>。</p>
<p>像其他函数一样，也可以通过向构造函数传递参数，指定对象该如何创建或设定对象 初始值。</p>
<p>构造函数和析构函数是两个非常特殊的函数:它们没有返回值。这与返回值为void的 函数显然不同。如果它们有返回值，要么编译器必须知 道如何处理返回值，要么就只能由客户程序员自己来显式地调用构造函数与析构函数，这 样一来，安全性就被破坏了。</p>
<h3 id="用析构函数确保清除"><a href="#用析构函数确保清除" class="headerlink" title="用析构函数确保清除"></a>用析构函数确保清除</h3><p>在C++中，清除就像初始化一样重要。它通过析构函数来保证清除的执行。析构函数的语法与构造函数一样，用类的名字作为函数名。然而析构函数前面加上一个 <strong>代字号(~)<strong>，以和构造函数区别。另外，</strong>析构函数不带任何参数，因为析构不需任何选项</strong>。<br>当对象超出它的作用域时，<strong>编译器</strong> 将自动调用析构函数。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/" rel="tag">Programming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/4-数据抽象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/15/Programming/C++/4-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"
    >第4章 数据抽象</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/15/Programming/C++/4-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/" class="article-date">
  <time datetime="2022-09-15T03:06:37.476Z" itemprop="datePublished">2022-09-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>库只是他人已经写好的一些代码，按某种方式包装在一起。通常，最小的包是带有扩 展名(如lib)的文件和向编译器声明库中有什么的一个或多个头文件。连接器知道如何 在库文件中搜索和提取相应的已编译的代码。但是，这只是提供库的一种方法。在跨越多 种体系结构的平台(例如Linux&#x2F;Unix)上，通常，提供库的最明智的方法是使用源代码， 这样它就能在新的目标机上被重新配置和编译。</p>
<p>所以，库大概是改进生产效率的最重要的方法。C++的主要设计目标之一就是使库使 用起来更加容易。这种说法暗示，在C中使用库有一些难度。理解这个因素将使我们对 C++设计有一个初步的了解，并因而对如何使用它有更深入的认识。</p>
<h4 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/" rel="tag">Programming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/3-Cpp中的C"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/14/Programming/C++/3-Cpp%E4%B8%AD%E7%9A%84C/"
    >第3章 Cpp中的C</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/14/Programming/C++/3-Cpp%E4%B8%AD%E7%9A%84C/" class="article-date">
  <time datetime="2022-09-14T09:51:13.575Z" itemprop="datePublished">2022-09-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/" rel="tag">Programming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/2-对象的创建与使用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/14/Programming/C++/2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"
    >第2章 对象的创建与使用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/14/Programming/C++/2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2022-09-14T09:42:53.496Z" itemprop="datePublished">2022-09-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>用户定义的数据类型或类(class)，是C++区别于传统过程型语言的地方。类是一种 新的数据类型，用来解决特定问题。一旦创建了一个类，任何人都可以使用它而不需知道 它的构造方式和工作原理细节。本章仅把类作为C++内置的另一种数据类型来使用。</p>
<h3 id="语言翻译过程"><a href="#语言翻译过程" class="headerlink" title="语言翻译过程"></a>语言翻译过程</h3><p>任何一种计算机语言都要从某种人们容易理解的形式(源代码)转化成计算机能执行 的形式(机器指令)。通常，翻译器分为两类:解释器(interpreter)和编译器 (compiler)。</p>
<h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><p>解释器将源代码转化成一些动作(它可由多组机器指令组成)并立即执行这些动作。</p>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>编译器直接把源代码转化成汇编语言或机器指令。最终的结果是一个或多个机器代码<br>的文件。这是一个复杂的过程，通常分几步完成。使用编译器时，从写源代码转到执行代<br>码，是一个较长的过程。</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>某些语言(特别是 C&#x2F;C++)编译时，首先要对源代码执行 <strong>预处理</strong>。</p>
<blockquote>
<p>预处理器(preprocessor)是一个简单的程序，它用程序员(利用预处理器指令)定义好的模式代替源代码中的模式。<br>预处理器指令用来节省输入，增加代码的可读性。</p>
</blockquote>
<p>编译一般分两遍进行。</p>
<blockquote>
<ol>
<li>首先，对预处理过的代码进行语法分析。编译器把源代码分解 成小的单元并把它们按树形结构组织起来。表达式“A+B”中的“A”、“+”和“B”就是语法分 析树的叶子节点。</li>
<li>编译的第二遍，由代码生成器(code generator)遍历语法分析树，把树的每个节点转 化成汇编语言或机器代码。如果代码生成器生成的是汇编语言，那么还必须用汇编器对其 汇编。</li>
</ol>
</blockquote>
<p>两种情况的最后结果都是生成目标模块(通常是，一个以.o或.obj为扩展名的文件)。</p>
<h5 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h5><p>类型检查(type checking)是 <strong>编译器在第一遍</strong> 中完成的。类型检查是检查函数参数是 否正确使用，以防止许多程序设计错误。由于类型检查是 <em><strong>在编译阶段而不是程序运行阶段</strong></em> 进行的，所以称之为静态类型检查(static type checking)。</p>
<h3 id="分段编辑工具"><a href="#分段编辑工具" class="headerlink" title="分段编辑工具"></a>分段编辑工具</h3><p>当创建大的项目时，分段编译尤其重要。在C&#x2F;C++中，可以将一个大程序构造成为许多小程序块，而这些小程序块容易管理，可独立测试。<br>程序分割的最基本的方法是创建命名子程序。在C和C++里，子程序称为函数(function)，函数是一段代码段，可以将这些函数放在不同的文件中，并能分别编译。另一种解释，<strong>函数是程序的基本单位</strong>，因为不能把一个函数分开，让其不同的部分放在不同的文件中;整个函数必须完整地放在一个文件里(尽管文件可拥有不止一个函数)。</p>
<p>编译一个文件时，C或C++编译器必须知道在另一些文件中的函数和数据，特别是它的名字和基本用法。编译器就是要确保函数和数据被正确地使用。<strong>“告知编译器”外部函数和数据的名称及它们的模样</strong>，这一过程就是声明(declaration)。</p>
<h4 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h4><blockquote>
<p>声明是向编译器介绍名字—标识符。它告诉编译器“这个函数或这个变量在某处可找到，它的模样像什么”。<br>而定义是说:“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的是函数还是变量，编译器都要为它们在定义点分配存储空间。</p>
</blockquote>
<p>对于变量，<strong>编译器确定变量的大小，然后在内存中开辟空间来保存变量的数据</strong>。对于函<br>数，编译器会生成代码，这些代码最终也要占用一定的内存。</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接器把由编译器生成的目标模块(一般是带“.o”或“.obj”扩展名的文件)连接成为操作系统可以加载和执行的程序。它是编译过程的最后阶段。</p>
<h4 id="使用库文件"><a href="#使用库文件" class="headerlink" title="使用库文件"></a>使用库文件</h4><p>使用库必须:</p>
<blockquote>
<ol>
<li>包含库的头文件。</li>
<li>使用库中的函数和变量。</li>
<li>把库连接进可执行程序。</li>
</ol>
</blockquote>
<p>当C或C++要对函数和变量进行外部引用时，根据引用情况，连接器会选择两种处理 方法中的一种。如果还未遇到过这个函数或变量的定义，连接器会把它的标识符加到“未 解析的引用”列表中。如果连接器遇到过函数或变量定义，那么这就是已解决的引用。</p>
<p>如果连接器在目标模块列表中不能找到函数或变量的定义，它将去查找库。库有某种 索引方式，连接器不必到库里查找所有目标模块—而只需浏览索引。当连接器在库中找到 定义后，就将整个目标模块而不仅仅是函数定义连接到可执行程序。</p>
<p>因为连接器按指定的顺序查找文件，所以，用户使用与库函数同名的函数，把带有这<br>种函数的文件插到库文件名列表之前，就能用他自己的函数取代库函数。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/" rel="tag">Programming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Programming/C++/1-对象导言"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/14/Programming/C++/1-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%A8%80/"
    >第1章 对象导言</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/14/Programming/C++/1-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%A8%80/" class="article-date">
  <time datetime="2022-09-14T08:47:46.075Z" itemprop="datePublished">2022-09-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a> / <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/">C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="抽象的过程"><a href="#抽象的过程" class="headerlink" title="抽象的过程"></a>抽象的过程</h3><p>所有的程序设计语言都是提供抽象。</p>
<blockquote>
<ol>
<li>万物皆对象；</li>
<li>程序就是一组对象，对象之间通过发送消息互相通知做什么；</li>
<li>每个对象否有自己的由其他对象构成的存储区；</li>
<li>每个对象都有一个类型；</li>
<li>一个特定类型的所有对象都能接收相同的消息。</li>
</ol>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/" rel="tag">Programming</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Xueru Wang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="WXR"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>